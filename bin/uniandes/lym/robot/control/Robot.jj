options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console; 
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.lang.String;
import java.lang.Integer;
import java.util.ArrayList;
@SuppressWarnings("serial")
public class Robot{

	public static HashMap<String, Integer> variables = new HashMap<String, Integer>();
	public static HashMap<String, ArrayList<String>> procedures = new HashMap<String, ArrayList<String>>();
	public static ArrayList<String> procedureArguments = new ArrayList<String>();
	public static String actualProcedureName = "";
	public static boolean inProcedureDefinition = false;

	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}
	
	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
		" "
	|	"\r"
	|	"\t"
	| 	"\n"
}

TOKEN: /* Reserved words*/
{
		< ROBOTR: "ROBOT_R" > 
	| 	< VARS: "VARS" > 
	| 	< PROCS: "PROCS" > 
}

TOKEN: /* Directions  */
{
	 	< LEFT:"left" > 
	| 	< AROUND:"around" >
	| 	< FRONT:"front" > 
	| 	< BACK:"back" > 
	| 	< NORTH:"north" > 
	| 	< SOUTH:"south" > 
	| 	< WEST:"west" > 
	| 	< EAST:"east" > 

}

TOKEN: /* Control structures */
{
	 	< IF:"if" > 
	| 	< THEN:"then" > 
	| 	< ELSE:"else" > 
	| 	< DO:"do" > 
	| 	< WHILE:"while" > 
	| 	< REPEAT:"repeat" > 
	| 	< FACING:"facing" > 
	| 	< CANPUT:"canput" > 
	| 	< CANPICK:"canpick" > 
	| 	< CANMOVEINDIR:"canmoveInDir" > 
	| 	< CANJUMPINDIR:"canJumpInDir" > 
	| 	< CANMOVETOTHE:"canMoveToThe" > 
	| 	< CANJUMPTOTHE:"canJumpToThe" > 
	| 	< NOT:"not" > 
}

TOKEN: /* Commands */
{
		< MOV:  "Mov" >
	| 	< RIGHT: "right" >
	| 	< PUT: "Put" >
	|	< PICK: "Pick" >
	|  	< POP: "Pop" >
	|  	< GO: "Go" >
    |  	< HOP: "Hop" >
	| 	< ASSIGNTO:"assignTo"> 
	| 	< GOTO:"goTo" > 
	| 	< MOVE:"move" > 
	|	< TURN:"turn" > 
	| 	< FACE:"face" >  
	| 	< MOVETOTHE:"moveToThe" > 
	| 	< MOVEINDIR:"moveInDir" > 
	| 	< JUMPTOTHE:"jumpToThe" > 
	| 	< JUMPINDIR:"jumpInDir" > 
	| 	< NOP:"nop" > 		
}

TOKEN /* Objects */:
{
		< BALLOONS: "BALLOONS" >
	|	< CHIPS: "CHIPS" >
}

TOKEN /* Special characters */:
{
	 	< COMMA:"," > 
	| 	< COLON : ":" >  
	| 	< SEMICOLON : ";" > 
	| 	< LBRACKET : "{" >  
	| 	< RBRACKET : "}" >  
	| 	< LSQUAREBRACKET : "[" > 
	| 	< RSQUAREBRACKET : "]" > 
	| 	< LPARENTHESIS : "(" >  
	| 	< RPARENTHESIS : ")" >
	| 	< BAR : "|" >
}

TOKEN /* Alphanumercis */:
{
	 	< NUMBER: ([ "0"-"9" ])+ >
	| 	< STRING: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z", "0"-"9"])* >
}


//boolean command(uniandes.lym.robot.view.Console sistema) :
boolean command(Console sistema):
{
  	int x,y;	
	salida=new String();
}
{ 
	program()
	{
	  
		try {
	    	Thread.sleep(900);
	    }
	    catch(InterruptedException e) {
	    	System.err.format("IOException: %s%n", e);
	    }
		return true;

	}

	| <EOF> {return false;} 

}

void program() :
{}
{
  < ROBOTR > [variablesDeclaration()] [proceduresDeclaration()] instructionsBlocK()
}

void variablesDeclaration() :
{}
{
  < VARS >  saveVariable()  (< COMMA > saveVariable())* < SEMICOLON >
}

void proceduresDeclaration() :
{}
{
  < PROCS > (saveProcedure() { Robot.inProcedureDefinition = true; } < LSQUAREBRACKET > < BAR > [saveVariable() (< COMMA > saveVariable())*] < BAR > instruction() (< SEMICOLON > instruction())*
  < RSQUAREBRACKET > saveAllProcedureArguments() restartProcedureAtributes() { Robot.inProcedureDefinition = false; })+	
}

void instructionsBlocK() :
{}
{
  < LSQUAREBRACKET > instruction() (< SEMICOLON > instruction())* < RSQUAREBRACKET >
}

void instruction() :
{}
{
		commandInstruction()
	|	structureControl()
	| 	procedureCall()
}

void commandInstruction() :
{
  int x=0;
  int y=0;
  String text = "";
  int direction = 0;
}
{
		< HOP > < LPARENTHESIS > x=charNumToInt() < RPARENTHESIS > {if(!inProcedureDefinition) { world.moveForward(x,true); }}
	| 	< POP > < LPARENTHESIS > x=charNumToInt() < RPARENTHESIS >  {if(!inProcedureDefinition) { world.popBalloons(x); }}
	|	< RIGHT > < LPARENTHESIS > < RPARENTHESIS > {if(!inProcedureDefinition) { world.turnRight();} }
	|  	< MOVE > < COLON > (x=charNumToInt() | x=getVariableValue()) {if(!inProcedureDefinition) {world.moveForward(x,false);} }
	| 	< ASSIGNTO > < COLON > x=charNumToInt() < COMMA > saveValueToVariable(x)
	| 	< GOTO > < COLON > (x=charNumToInt() | x=getVariableValue()) < COMMA > (y=charNumToInt() | y=getVariableValue()) {if(!inProcedureDefinition) {world.setPostion(x,y);} } 
	| 	< TURN > < COLON > (turnDirection())
	| 	< FACE > < COLON >(x=getDirection()) {if(!inProcedureDefinition) {faceLexer(x); }}
	| 	< PUT > < COLON > (x=charNumToInt() | x=getVariableValue()) < COMMA > (< BALLOONS > {if(!inProcedureDefinition) {world.putBalloons(x); }} | < CHIPS > {if(!inProcedureDefinition) {world.putChips(x); }})
	| 	< PICK > < COLON > (x=charNumToInt() | x=getVariableValue()) < COMMA > (< BALLOONS > {if(!inProcedureDefinition) {world.grabBalloons(x); }} | < CHIPS > {if(!inProcedureDefinition) {world.pickChips(x); }})
	| 	< MOVETOTHE > < COLON > (x=charNumToInt() | x=getVariableValue()) < COMMA > text=getNormalDirection() { moveToTheLexer(x, text);}
	| 	< JUMPTOTHE > < COLON > (x=charNumToInt() | x=getVariableValue()) < COMMA > text=getNormalDirection() { jumpToTheLexer(x, text);}
	| 	< MOVEINDIR > < COLON > (x=charNumToInt() | x=getVariableValue()) < COMMA > (direction = getDirection()){if(!inProcedureDefinition) {faceLexer(direction); world.moveForward(x,false);}}
	|   < JUMPINDIR > < COLON > (x=charNumToInt() | x=getVariableValue()) < COMMA > (direction = getDirection()){if(!inProcedureDefinition) {faceLexer(direction); world.moveForward(x,true);}} 
	| 	< NOP > <COLON >
	
}

void structureControl():
{}
{
  		conditionalIf() 
	| 	loop()
	|   repeat()	
}

void conditionalIf():
{}
{
	< IF > < COLON > condition() < THEN > < COLON > instructionsBlocK() < ELSE > < COLON > instructionsBlocK()
}
void loop():
{}
{
	< WHILE > < COLON > condition() < DO > < COLON > instructionsBlocK()
}

void repeat():
{
}
{
	< REPEAT > < COLON > (<NUMBER> | <STRING>) instructionsBlocK()
} 
  
void condition():
{}
{
	facing()
  |	canPut()
  |	canPick()
  |	canMoveIn()
  |	canJumpIn()
  |	canMoveTo()
  |	canJumpTo()
  |	not()
}

void facing():
{}
{
	< FACING > < COLON > (< NORTH > | < SOUTH > | < EAST > | < WEST >)
}

void canPut():
{}
{
 	< CANPUT > < COLON > (< NUMBER > | < STRING >) < COMMA > (< CHIPS > | < BALLOONS >) 
}

void canPick():
{}
{
  	< CANPICK > <COLON> (<NUMBER> | <STRING>) <COMMA> (<CHIPS>|<BALLOONS>) 
}

void canMoveIn():
{}
{
  < CANMOVEINDIR > < COLON > (< NUMBER > | < STRING >) < COMMA > (< NORTH > | < SOUTH > | < EAST > | < WEST >) 
}

void canJumpIn():
{}
{
  < CANJUMPINDIR > < COLON > (< NUMBER > | < STRING >) < COMMA > (< NORTH > | < SOUTH > | < EAST > | < WEST >)
}

void canMoveTo():
{}
{
  < CANMOVETOTHE > < COLON > (< NUMBER > | < STRING >) < COMMA > (< FRONT > | < RIGHT > | < LEFT > | < BACK >) 
}

void canJumpTo():
{}
{
  < CANJUMPTOTHE > < COLON > (< NUMBER > | < STRING >) < COMMA > (< FRONT > | < RIGHT > | < LEFT > | < BACK >) 
}

void not():
{}
{
  < NOT > < COLON > condition()
}

void procedureCall() :
{
	int expectedArguments = 0;
	int argumentCounter = 0;
}
{
	isAProcedure() { expectedArguments = procedures.get(token.image).size(); } < COLON > [(getVariableValue() { argumentCounter = argumentCounter+1; } | < NUMBER > { argumentCounter = argumentCounter+1; }) (< COMMA > (getVariableValue() { argumentCounter = argumentCounter+1; } | < NUMBER > { argumentCounter = argumentCounter+1; }))*] { if(expectedArguments !=  argumentCounter) {throw new Error("The expected arguments does not match with the recieved arguments.");} }
}

int charNumToInt() throws Error:
{	
	int total=1;
}
{
	< NUMBER >
	{
		try{
			total = Integer.parseInt(token.image);
		} 
		catch (NumberFormatException ee){
			throw new Error("Number out of bounds: "+token.image+" !!");
		}
		return total;
	}
}

void saveVariable():
{
	String variableName = "";
}
{
	< STRING >
	{
		variableName=token.image;
		if(inProcedureDefinition) {
		  Robot.variables.put(variableName, 0);
		Robot.procedureArguments.add(variableName);
		}
		else { 
			Robot.variables.put(variableName, -1);
		}
		/*System.out.println(Robot.variables.keySet());*/
	}
}

void saveValueToVariable(int value) throws Error:
{
	String variableName = "";
}
{
	< STRING >
	{
		variableName=token.image;
		if(Robot.variables.replace(variableName, value) != null) {
		  Robot.variables.replace(variableName, value);
		}
		else{
		  throw new Error("The variable " + variableName +  " has not been declared.");
		}
		/*System.out.println(Robot.variables.toString());*/
	}
}

int getVariableValue() throws Error:
{
	int variableValue = 0;
	String variableName = "";
}
{
	< STRING >
	{
		variableName=token.image;
		if(Robot.variables.containsKey(variableName)) {
		  	variableValue = Robot.variables.get(variableName);
		}
		else{
		  	throw new Error("The variable " + variableName +  " has not been declared.");
		}
		if(variableValue == -1) {
			throw new Error("The variable " + variableName +  " has not been initialized.");
		}
		return variableValue;
	}
}

void saveProcedure():
{
  	String procedureName = "";
}
{
	< STRING >
	{
		procedureName = token.image;
		Robot.actualProcedureName = procedureName;
		Robot.procedures.put(procedureName, new ArrayList<String >());
	}
}

void saveProcedureArgument():
{
  String procedureArgumentName = "";
}
{
  	< STRING >
	{
  		procedureArgumentName = token.image;
  		Robot.procedureArguments.add(procedureArgumentName);
	}
}

void saveAllProcedureArguments():
{
}
{
  {
    if(Robot.procedures.replace(Robot.actualProcedureName, Robot.procedureArguments) != null) { 
    	Robot.procedures.replace(Robot.actualProcedureName, Robot.procedureArguments);
  	}
  }
}

void restartProcedureAtributes():
{
}
{
  {
    Robot.actualProcedureName = "";
    Robot.procedureArguments = new ArrayList<String>();
  } 
}

void isAnArgumentString():
{
  String argumentName = "";
}
{
  < STRING >
  {
    argumentName = token.image;
    
    
    
  }
}

void isAProcedure():
{
  String procedureName = "";
}
{
  < STRING >
  {
    procedureName = token.image;
    
    if(Robot.procedures.get(procedureName) ==  null) {
		throw new Error("The procedure " + procedureName +  " has not been declared.");
    }
    else {
		Robot.actualProcedureName = procedureName;
    }
  }
}

String getNormalDirection():
{
  String direction = "";
}
{
  	(	  	  	< FRONT >
		| 	< RIGHT >
		| 	< LEFT >
		| 	< BACK >
	) { direction = token.image; return direction; }
}

void moveToTheLexer(int steps, String direction) :
{
	int facing = world.getFacing();
}
{
	{
		if(direction.toLowerCase().equals("front")) {
			if(facing == 1) {
			  while(steps > 0) {
			   	world.down();
			   	steps = steps-1;
			  }
			}
			if(facing == 2) {
			  while(steps > 0) {
			   	world.right();
			   	steps = steps-1;
			  }
			}
			if(facing == 0) {
			  while(steps > 0) {
			   	world.up();
			   	steps = steps-1;
			  }
			}
			if(facing == 3) {
			  while(steps > 0) {
			   	world.left();
			   	steps = steps-1;
			  }
			}
		}
		if(direction.toLowerCase().equals("left")) {
			if(facing == 1) {
			  while(steps > 0) {
			   	world.right();
			   	steps = steps-1;
			  }
			}
			if(facing == 2) {
			  while(steps > 0) {
			   	world.up();
			   	steps = steps-1;
			  }
			}
			if(facing == 0) {
			  while(steps > 0) {
			   	world.left();
			   	steps = steps-1;
			  }
			}
			if(facing == 3) {
			  while(steps > 0) {
			   	world.down();
			   	steps = steps-1;
			  }
			}
		}
		if(direction.toLowerCase().equals("right")) {
			if(facing == 1) {
			  while(steps > 0) {
			   	world.left();
			   	steps = steps-1;
			  }
			}
			if(facing == 2) {
			  while(steps > 0) {
			   	world.down();
			   	steps = steps-1;
			  }
			}
			if(facing == 0) {
			  while(steps > 0) {
			   	world.right();
			   	steps = steps-1;
			  }
			}
			if(facing == 3) {
			  while(steps > 0) {
			   	world.up();
			   	steps = steps-1;
			  }
			}
		}
		if(direction.toLowerCase().equals("back")) {
			if(facing == 1) {
			  while(steps > 0) {
			   	world.up();
			   	steps = steps-1;
			  }
			}
			if(facing == 2) {
			  while(steps > 0) {
			   	world.left();
			   	steps = steps-1;
			  }
			}
			if(facing == 0) {
			  while(steps > 0) {
			   	world.down();
			   	steps = steps-1;
			  }
			}
			if(facing == 3) {
			  while(steps > 0) {
			   	world.right();
			   	steps = steps-1;
			  }
			}
		}
	}
}

void jumpToTheLexer(int steps, String direction) :
{
	int facing = world.getFacing();
}
{
	{
		if(direction.toLowerCase().equals("front")) {
			world.moveForward(steps,true);
		}
		if(direction.toLowerCase().equals("right")) {
			world.turnRight();
			world.moveForward(steps,true);
		}
		if(direction.toLowerCase().equals("back")) {
			world.turnRight();
			world.turnRight();
			world.moveForward(steps,true);
		}
		if(direction.toLowerCase().equals("left")) {
			world.turnRight();
			world.turnRight();
			world.turnRight();
			world.moveForward(steps,true);
		}
	}
}

void turnDirection():
{
  String direction = "";
}
{
  	(< AROUND >| < RIGHT >| < LEFT >)
  	 {
  	   direction = token.image;
  	   
		if(direction.toLowerCase().equals("around")) {
			for (int i=0;i<4;i++) {
			  	world.turnRight();
			}
    	}
    	else if (direction.toLowerCase().equals("right")) {
			world.turnRight();
    	}
    	else if (direction.toLowerCase().equals("left")) {
			for (int i=0;i<3;i++) {
			  	world.turnRight();
			}
    	}
	 }
}

int getDirection():
{
  String direction; 
}
{
  (< NORTH > | < SOUTH > | < EAST > | < WEST >)
  {
    direction = token.image;
    
    if(direction.toLowerCase().equals("north")) {
		return 0;
    }
    else if (direction.toLowerCase().equals("south")) {
		return 1;
    }
    else if (direction.toLowerCase().equals("east")) {
		return 2;
    }
    else if (direction.toLowerCase().equals("west")) {
		return 3;
    }
    return -1;
  }
  
}

void faceLexer(int x):
{
  int timesOfTurnRight = 0;
}
{
  {
    int actualFacing = world.getFacing();
	
    if(actualFacing == 0 && x == 1) {
		timesOfTurnRight = 2;
   	}
   	else if(actualFacing == 2 && x == 1) {
		timesOfTurnRight = 1;
  	}
  	else if(actualFacing == 3 && x == 1) {
		timesOfTurnRight = 3;
  	}
  	else if(actualFacing == 0 && x == 2) {
		timesOfTurnRight = 1;
   	}
   	else if(actualFacing == 3 && x == 2) {
		timesOfTurnRight = 2;
  	}
  	else if(actualFacing == 1 && x == 2) {
		timesOfTurnRight = 3;
  	}
  	else if(actualFacing == 0 && x == 3) {
		timesOfTurnRight = 3;
   	}
   	else if(actualFacing == 1 && x == 3) {
		timesOfTurnRight = 1;
  	}
  	else if(actualFacing == 2 && x == 3) {
		timesOfTurnRight = 2;
  	}
  	else if(actualFacing == 1 && x == 0) {
		timesOfTurnRight = 2;
   	}
   	else if(actualFacing == 2 && x == 0) {
		timesOfTurnRight = 3;
  	}
  	else if(actualFacing == 3 && x == 0) {
		timesOfTurnRight = 1;
  	}
   	for(int i=0;i<timesOfTurnRight;i++) {
		world.turnRight();
  	}  
  }
}