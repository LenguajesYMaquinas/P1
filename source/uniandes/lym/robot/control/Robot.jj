options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console; 
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.lang.String;
import java.lang.Integer;

@SuppressWarnings("serial")
public class Robot{

	public static HashMap<String, Integer> variables = new HashMap<String, Integer>();

	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}
	
	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
		" "
	|	"\r"
	|	"\t"
	| 	"\n"
}

TOKEN: /* Reserved words*/
{
		< ROBOTR: "ROBOT_R" > 
	| 	< VARS: "VARS" > 
	| 	< PROCS: "PROCS" > 
}

TOKEN: /* Directions  */
{
	 	< LEFT:"left" > 
	| 	< AROUND:"around" >
	| 	< FRONT:"front" > 
	| 	< BACK:"back" > 
	| 	< NORTH:"north" > 
	| 	< SOUTH:"south" > 
	| 	< WEST:"west" > 
	| 	< EAST:"east" > 

}

TOKEN: /* Control structures */
{
	 	< IF:"if" > 
	| 	< THEN:"then" > 
	| 	< ELSE:"else" > 
	| 	< DO:"do" > 
	| 	< WHILE:"while" > 
	| 	< REPEAT:"repeat" > 
	| 	< FACING:"facing" > 
	| 	< CANPUT:"canput" > 
	| 	< CANPICK:"canpick" > 
	| 	< CANMOVEINDIR:"canmoveInDir" > 
	| 	< CANJUMPINDIR:"canJumpInDir" > 
	| 	< CANMOVETOTHE:"canMoveToThe" > 
	| 	< CANJUMPTOTHE:"canJumpToThe" > 
	| 	< NOT:"not" > 
}

TOKEN: /* Commands */
{
		< MOV:  "Mov" >
	| 	< RIGHT: "right" >
	| 	< PUT: "Put" >
	|	< PICK: "Pick" >
	|  	< POP: "Pop" >
	|  	< GO: "Go" >
    |  	< HOP: "Hop" >
	| 	< ASSIGNTO:"assignTo"> 
	| 	< GOTO:"goTo" > 
	| 	< MOVE:"move" > 
	|	< TURN:"turn" > 
	| 	< FACE:"face" >  
	| 	< MOVETOTHE:"moveToThe" > 
	| 	< MOVEINDIR:"moveInDir" > 
	| 	< JUMPTOTHE:"jumpToThe" > 
	| 	< JUMPINDIR:"jumpInDir" > 
	| 	< NOP:"nop" > 		
}

TOKEN /* Objects */:
{
		< BALLOONS: "BALLOONS" >
	|	< CHIPS: "CHIPS" >
}

TOKEN /* Special characters */:
{
	 	< COMMA:"," > 
	| 	< COLON : ":" >  
	| 	< SEMICOLON : ";" > 
	| 	< LBRACKET : "{" >  
	| 	< RBRACKET : "}" >  
	| 	< LSQUAREBRACKET : "[" > 
	| 	< RSQUAREBRACKET : "]" > 
	| 	< LPARENTHESIS : "(" >  
	| 	< RPARENTHESIS : ")" >
	| 	< BAR : "|" >
}

TOKEN /* Alphanumercis */:
{
	 	< NUMBER: ([ "0"-"9" ])+ >
	| 	< STRING: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z", "0"-"9"])* >
}


//boolean command(uniandes.lym.robot.view.Console sistema) :
boolean command(Console sistema):
{
  	int x,y;	
	salida=new String();
}
{ 
	program()
	{
	  
		try {
	    	Thread.sleep(900);
	    }
	    catch(InterruptedException e) {
	    	System.err.format("IOException: %s%n", e);
	    }
		return true;

	}

	| <EOF> {return false;} 

}

void program() :
{}
{
  < ROBOTR > [variablesDeclaration()] [proceduresDeclaration()] instructionsBlocK()
}

void variablesDeclaration() :
{}
{
  < VARS >  saveVariable()  (< COMMA > saveVariable())* < SEMICOLON >
}

void proceduresDeclaration() :
{}
{
  < PROCS > (< STRING > < LSQUAREBRACKET > < BAR > [< STRING > (< COMMA > < STRING >)*] < BAR > instruction() (< SEMICOLON > instruction())* < RSQUAREBRACKET >)+
}

void instructionsBlocK() :
{}
{
  < LSQUAREBRACKET > instruction() (< SEMICOLON > instruction())* < RSQUAREBRACKET >
}

void instruction() :
{}
{
		commandInstruction()
	|	structureControl()
	| 	procedureCall()
}

void commandInstruction() :
{
  int x=0;
  int y=0;
  String text = "";
}
{
		< HOP > < LPARENTHESIS > x=charNumToInt() < RPARENTHESIS > {world.moveForward(x,true);}
	| 	< POP > < LPARENTHESIS > x=charNumToInt() < RPARENTHESIS >  {world.popBalloons(x);}
	|	< RIGHT > < LPARENTHESIS > < RPARENTHESIS > {world.turnRight();}
	|  	< MOVE > < COLON > (x=charNumToInt() | < STRING >) {world.moveForward(x,false);} 
	| 	< ASSIGNTO > < COLON > x=charNumToInt() < COMMA > saveValueToVariable(x)
	| 	< GOTO > < COLON > (x=charNumToInt() | < STRING >) < COMMA > (y=charNumToInt() | < STRING >) {world.setPostion(x,y);} 
	| 	< TURN > < COLON > (< LEFT > | < RIGHT > | < AROUND >)
	| 	< FACE > < COLON > (< NORTH > | < SOUTH > | < EAST > | < WEST >)
	| 	< PUT > < COLON > (x=charNumToInt() | < STRING >) < COMMA > (< BALLOONS > {world.putBalloons(x);} | < CHIPS > {world.putChips(x);})
	| 	< PICK > < COLON > (x=charNumToInt() | < STRING >) < COMMA > (< BALLOONS > {world.grabBalloons(x);} | < CHIPS > {world.pickChips(x);})
	| 	< MOVETOTHE > < COLON > (< NUMBER > | < STRING >) < COMMA > (< FRONT > | < LEFT > | < RIGHT > | < BACK >)
	| 	< JUMPTOTHE > < COLON > (< NUMBER > | < STRING >) < COMMA > (< FRONT > | < LEFT > | < RIGHT > | < BACK >)
	| 	< MOVEINDIR > < COLON > (< NUMBER > | < STRING >) < COMMA > (< NORTH > | < SOUTH > | < EAST > | < WEST >)
	|   < JUMPINDIR > < COLON > (< NUMBER > | < STRING >) < COMMA > (< NORTH > | < SOUTH > | < EAST > | < WEST >)
	| 	< NOP > <COLON >
	
}

void structureControl():
{ }
{
  		conditionalIf()
	| 	loop()
	|   repeat()	
}

void conditionalIf():
{}
{
	< IF > < COLON > condition() < THEN > < COLON > instructionsBlocK() < ELSE > < COLON > instructionsBlocK()
}
void loop():
{}
{
	< WHILE > < COLON > condition() < DO > < COLON > instructionsBlocK()
}

void repeat():
{
}
{
	< REPEAT > < COLON > (<NUMBER> | <STRING>) instructionsBlocK()
} 
  
void condition():
{}
{
	facing()
  |	canPut()
  |	canPick()
  |	canMoveIn()
  |	canJumpIn()
  |	canMoveTo()
  |	canJumpTo()
  |	not()
}

void facing():
{}
{
	< FACING > < COLON > (< NORTH > | < SOUTH > | < EAST > | < WEST >)
}

void canPut():
{}
{
 	< CANPUT > < COLON > (< NUMBER > | < STRING >) < COMMA > (< CHIPS > | < BALLOONS >) 
}

void canPick():
{}
{
  	< CANPICK > <COLON> (<NUMBER> | <STRING>) <COMMA> (<CHIPS>|<BALLOONS>) 
}

void canMoveIn():
{}
{
  < CANMOVEINDIR > < COLON > (< NUMBER > | < STRING >) < COMMA > (< NORTH > | < SOUTH > | < EAST > | < WEST >) 
}

void canJumpIn():
{}
{
  < CANJUMPINDIR > < COLON > (< NUMBER > | < STRING >) < COMMA > (< NORTH > | < SOUTH > | < EAST > | < WEST >)
}

void canMoveTo():
{}
{
  < CANMOVETOTHE > < COLON > (< NUMBER > | < STRING >) < COMMA > (< FRONT > | < RIGHT > | < LEFT > | < BACK >) 
}

void canJumpTo():
{}
{
  < CANJUMPTOTHE > < COLON > (< NUMBER > | < STRING >) < COMMA > (< FRONT > | < RIGHT > | < LEFT > | < BACK >) 
}

void not():
{
}
{
  < NOT > < COLON > condition()
}

void procedureCall() :
{}
{
	< STRING > < COLON > [(< STRING > | < NUMBER >) (< COMMA > (< STRING > | < NUMBER >))*]
}

int charNumToInt() throws Error:
{	
	int total=1;
}
{
	< NUMBER >
	{
		try{
			total = Integer.parseInt(token.image);
		} 
		catch (NumberFormatException ee){
			throw new Error("Number out of bounds: "+token.image+" !!");
		}
		return total;
	}
}

void saveVariable():
{
	String variableName = "";
}
{
	< STRING >
	{
		variableName=token.image;
		Robot.variables.put(variableName, -1);
		/*System.out.println(Robot.variables.keySet());*/
	}
}

void saveValueToVariable(int value) throws Error:
{
	String variableName = "";
}
{
	< STRING >
	{
		variableName=token.image;
		if(Robot.variables.replace(variableName, value) != null) {
		  Robot.variables.replace(variableName, value);
		}
		else{
		  throw new Error("The variable " + variableName +  " has not been declared.");
		}
		/*System.out.println(Robot.variables.toString());*/
	}
}